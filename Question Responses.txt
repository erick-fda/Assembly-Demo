==========================================================================================
    COMP 8551 Assignment 03
    
    Erick Fernandez de Arteaga, A00925871
    John Janzen,                A00844492

    Version 0.1.0
    
==========================================================================================

------------------------------------------------------------------------------------------
    TABLE OF CONTENTS
    
    ## Part A
    ## Part C
    ## Part D
    
------------------------------------------------------------------------------------------

==========================================================================================
    ## Part A
==========================================================================================
The blitBlend() function produces the result image obtained by blending the two 
component images. Regardless of the SIMD mode, the function begins by determining the 
area of the image to be blended and beginning a for loop that will execute for every 
line of pixels within this area. Descriptions of the details for each mode follow: 

----- Mode: SIMD_NONE -----

In the basic serial implementation, for each pixel in the blend area, each of the three 
color channels is processed in the following way:

				diff = *pSrc[0] - *pDst[0];
				tmp = short(*pSrc[3] * diff) >> 8;
				*pDst[0] = tmp + *pDst[0];

What this does is to take the difference between the two images for that color channel, 
scale it by the source image's alpha value, bitwise shift right by 8 (essentially 
dividing the number by 2^8, or 256, diminshing the influence of the source image on the 
result image). Lastly, the resulting value is added to the corresponding color channel for 
the result image.

Once the resulting color channels have been determined, the coordinate values for the 
source and destination images are updated so that the next pixel location in each can be 
processed next.


----- Mode: SIMD_EMMX_INTRINSICS -----

            for (unsigned x = X0; x < X1; x += 16) {

The for loop for the intrinsic explanation is slightly different since it loops over bits 
instead of pixels. Thus the increment value is 16 instead of 1.


				register __m128i s0, s1, d0, d1, a0, a1, r0, r1, zero;
				register __m128i diff0, tmp0, diff1, tmp1, t;
				zero = _mm_setzero_si128();

The first two lines here declare local variables for manipulating register values. The 
third initializes the variable zero to a 128-bit zero value.

				t = _mm_loadu_si128((__m128i *) pSrc[3]);
				a0 = _mm_unpacklo_epi8(t, zero);
				a1 = _mm_unpackhi_epi8(t, zero);

The first line here loads the source image's alpha value into the register t as a 128-bit 
number. The second line takes the lower 64 bits from t and zero and combines them in an 
ABAB pattern, then stores them in a0. The third line does the same, but for the *upper* 64 
bits from each, storing the result in a1.

                t = _mm_loadu_si128((__m128i *) pDst[(comp)]);                      \
                d0 = _mm_unpacklo_epi8(t, zero);                                    \
                d1 = _mm_unpackhi_epi8(t, zero);                                    \
                t = _mm_loadu_si128((__m128i *) pSrc[(comp)]);                      \
                _mm_storeu_si128(                                           // Store result value.
                                    (__m128i *) pDst[(comp)],                   // Value is stored in destination color channel. 
                                    _mm_packus_epi16(                           // Combine two 128-bit signed sources into a 128-bit unsigned result.
                                        _mm_srli_epi16(                             // Bitwise right-shift first parameter by second parameter value.
                                            _mm_add_epi16(                              // Add the two parameters.
                                                _mm_mullo_epi16(                            // Multiply the two parameters.
                                                    _mm_unpacklo_epi8(                          // Combine the lower 64 bits of the two parameters in a bitwise ABAB pattern.
                                                        t,                                          // Source image color channel value.
                                                        zero),                                      // Zero
                                                    a0),                                        // ABAB-combined lower 64 bits from source image alpha and zero. 
                                                _mm_mullo_epi16(                            // Multiply the two parameters.
                                                    _mm_sub_epi16(                              // Subtracts the second parameter from the first.
                                                        ff,                                         // Maximum value for 128-bit number.
                                                        a0),                                        // ABAB-combined lower 64 bits from source image alpha and zero.
                                                    d0)),                                       // ABAB-combined lower 64 bits from destination image color channel and zero.
                                            8),                                         // Right-shift by 8 bits (i.e., divide by 256).
                                        _mm_srli_epi16(                             // Bitwise right-shift first parameter by second parameter value.
                                            _mm_add_epi16(                              // Add the two parameters.
                                                _mm_mullo_epi16(                            // Multiply the two parameters.
                                                    _mm_unpackhi_epi8(                          // Combine the upper 64 bits of the two parameters in a bitwise ABAB pattern.
                                                        t,                                          // Source image color channel value.
                                                        zero),                                      // Zero
                                                    a1),                                        // ABAB-combined upper 64 bits from source image alpha and zero. 
                                                _mm_mullo_epi16(                            // Multiply the two parameters
                                                    _mm_sub_epi16(                              // Subtract the second parameter from the first.
                                                        ff,                                         // Maximum value for 128-bit number.
                                                        a1),                                        // ABAB-combined upper 64 bits from source image alpha and zero.
                                                    d1)),                                       // ABAB-combined upper 64 bits from destination image color channel and zero.
                                            8)))                                        // Right-shift by 8 bits (i.e., divide by 256).

The above lines are executed for each color channel, with the comp variable indicating 
the index of the color channel. The first three statements do the same as the three lines 
discussed previously to this (load value into t, load first and last 64 bits into d0 and 
d1 after combining with zero bits in ABAB pattern) for the color channel from the 
destination image.

The fourth statement loads the value of the corresponding color channel from the source 
image into t.

The last statement is commented in detail above. To summarize it, for the first 
and last 64 bits of the result, the corresponding color channel is taken from the source 
and destination images and scaled according to the source image's alpha. These two values 
(from the source and destination image) are then added. The sum is then bitwise 
right-shifted by 8. Then the first and last 64 bits are combined to create the resulting 
128 bit value.

				pSrc[0] += 16;
				pSrc[1] += 16;
				pSrc[2] += 16;
				pSrc[3] += 16;

				pDst[0] += 16;
				pDst[1] += 16;
				pDst[2] += 16;

The last few line of code here simply increment the pixel coordinates for the source and 
destination images. As previously mentioned, the intrinsic for loop operates on bits 
rather than pixels, which is why the increment values are 16 in each case instead of one. 


----- Mode: SIMD_EMMX -----

			for (unsigned x = X0; x < X1; x += 16) {
				__asm {

Similar to the SIMD_EMMX_INTRINSICS mode, the loop operates on bits rather than pixels, 
so the increment value is 16.

					pxor xmm0, xmm0 // xmm0 <- 0
					mov eax, dword ptr [pSrc + 12]
					movdqu xmm1, [eax]; xmm1 <- *pSrc[3]
					movdqa xmm2, xmm1; 
					punpcklbw xmm2, xmm0; // xmm2 <- a0, 16bit
					movdqa xmm3, xmm1;
					punpckhbw xmm3, xmm0; // xxm3 <- a1, 16bit

The first line performs a bitwise exclusive or on the first Streaming SIMD Extensions 
(SSE) register with itself and stores the result in that register. The result of a pxor 
of something on itself is always zero, so this is equivalent to hardcoding a starting 
value of zero for the register. The second line stores a pointer to pSrc[3], or the 
source image's alpha, into the eax register. The third line stores this pointer in the 
xmm1 register. The fourth line stores this pointer in the xmm2 register as well, but 
assumes the source register is an aligned memory location. The fifth line takes the lower 
bits from xmm0 (zero) and xmm2 (source alpha) and interleaves them in an ABAB pattern, 
storing the result in xmm2. The sixth line stores another aligned pointer to the source 
alpha in xmm3. The seventh line is similar to the fifth, but takes the *upper* bits from 
xmm0 (zero) and xmm3 (source alpha), interleaves them, and stores the result in xmm3.

					mov eax, dword ptr[pDst + 0]; 
					movdqu xmm1, [eax]; // xmm1 = pDst[0]
					movdqa xmm6, xmm1;
					punpcklbw xmm6, xmm0; // xmm6 <- pDst[0] low 16bit
					movdqa xmm7, xmm1;
					punpckhbw xmm7, xmm0; // xmm7 <- pDst[0] high, 16 bit

The first line stores a pointer to the destination's red channel in the eax register. The 
second line stores a pointer to this in the xmm1 register. The third line stores an 
aligned pointer to this in the xmm6 register. The fourth line interleaves the lower xmm0 
(zero) and xmm6 (destination red channel) bits and stores the result in xmm6. The fifth 
line stores an aligned pointer to the destination red channel in the xmm7 register. The 
sixth line interleaves the xmm0 (zero) and xmm7 (destination red channel) bits and stores 
the result in xmm7.

					movdqu xmm4, [ffconst]; // xmm4 <- ff
					movdqa xmm5, xmm4; 
					psubw  xmm5, xmm2; // xmm5 = ff - a0
					pmullw xmm6, xmm5; // xmm6 = (ff - a0) * d0;

The first line stores a pointer to the ff constant (previously initialized as the max 
128-bit value, all ones) in the xmm4 register. The second line stores an aligned pointer 
to the same in the xmm5 register. The third line subtracts xmm2 (interleaved lower bits 
of source alpha and zero) from xmm5 (max 128-bit value) and stores the result in xmm5. 
The fourth line multiplies this difference by xmm6 (interleaved lower bits of destination 
red channel and zero) and stores the product in xmm6.

					movdqa xmm5, xmm4;
					psubw  xmm5, xmm3; // xmm5 = ff - a1
					pmullw xmm7, xmm5; // xmm7 = (ff - a1) * d1;

The first line stores an aligned pointer to the ff constant in xmm5. The second line 
subtracts xmm3 (interleaved upper bits of source alpha and zero) from the ff constant and 
stores the result in xmm5. The third line multiplies this difference by xmm7 (interleaved 
upper bits of destination red channel and zero).

					mov eax, dword ptr[pSrc + 0];
					movdqu xmm1, [eax]; // xmm1 = pSrc[0]

The first line stores a pointer to the source image's red channel in the eax register. 
The second line stores a pointer to the same in xmm1.

					movdqa xmm5, xmm1;
					punpcklbw xmm5, xmm0; // xmm5 = pSrc[0], low, 16 bit;
					pmullw xmm5, xmm2; // xmm5 = s0 * a0;
					paddw xmm6, xmm5; // xmm6 = s0 * a0 + (ff - a0) * d0;

The first line stores an aligned pointer to the source image's red channel in xmm5. The 
second line interleaves the lower bits from xmm0 (zero) and xmm5 (source red channel) and 
stores the result in xmm5. The third line multiplies this by xmm2 (interleaved 
lower bits of source alpha and zero) and stores the result in xmm5. The fourth line adds 
this product to xmm6 (the previously calculated lower bits) and stores the sum in xmm6 to 
calculate the lower bits for the result red channel.

					movdqa xmm5, xmm1;
					punpckhbw xmm5, xmm0;
					pmullw xmm5, xmm3; // xmm5 = s1 * a1
					paddw xmm7, xmm5; // xmm7 = s1 * a1 + (ff - a1) * d1;

The first line stores an aligned pointer to the source image's red channel in xmm5. The 
second line interleaves the higher bits from xmm0 (zero) and xmm5 (source red channel) 
and stores the result in xmm5. The third line multiplies this by xmm3 (interleaved upper 
bits of source alpha and zero) and stores the product in xmm5. The fourthline adds this 
product to xmm7 (the previously calculated upper bits) and stores the sum in xmm7 to 
calculate the upper bits for the result red channel.

					psrlw xmm6, 8;
					psrlw xmm7, 8;

The first line bitwise right-shifts the calculated lower bits in xmm6 by 8 (i.e., divides 
the stored value by 2^8, or 256). The second line does the same for the calculated upper 
bits in xmm7.

					packuswb xmm6, xmm7; // xmm6 <- xmm6{}xmm7 low bits;
					mov eax, dword ptr [pDst + 0];
					movdqu [eax], xmm6; // done for this component;

The first line combines the lower and upper bits stored in xmm6 and xmm7 and stores the 
result in xmm6. The second line gets a pointer to the result image's red channel and 
stores it in the eax register. The third line stores the result of all the red channel 
calculations into the result image's red channel. The final red value is done being 
calculated.

					// blending the green;
					// load d0
					mov eax, dword ptr[pDst + 4]; 
					movdqu xmm1, [eax]; // xmm1 = pDst[0]
					movdqa xmm6, xmm1;
					punpcklbw xmm6, xmm0; // xmm6 <- pDst[0] low 16bit
					movdqa xmm7, xmm1;
					punpckhbw xmm7, xmm0; // xmm7 <- pDst[0] high, 16 bit
					// load the ff constant
					movdqu xmm4, [ffconst]; // xmm4 <- ff
					movdqa xmm5, xmm4; 
					psubw  xmm5, xmm2; // xmm5 = ff - a0
					pmullw xmm6, xmm5; // xmm6 = (ff - a0) * d0;
					// now for the upper bits
					movdqa xmm5, xmm4;
					psubw  xmm5, xmm3; // xmm5 = ff - a1
					pmullw xmm7, xmm5; // xmm7 = (ff - a1) * d1;
					// load the source;
					mov eax, dword ptr[pSrc + 4];
					movdqu xmm1, [eax]; // xmm1 = pSrc[0]
					// low bits of pSrc[0]
					movdqa xmm5, xmm1;
					punpcklbw xmm5, xmm0; // xmm5 = pSrc[0], low, 16 bit;
					pmullw xmm5, xmm2; // xmm5 = s0 * a0;
					paddw xmm6, xmm5; // xmm6 = s0 * a0 + (ff - a0) * d0;
					// high bits of pSrc[0]
					movdqa xmm5, xmm1;
					punpckhbw xmm5, xmm0;
					pmullw xmm5, xmm3; // xmm5 = s1 * a1
					paddw xmm7, xmm5; // xmm7 = s1 * a1 + (ff - a1) * d1;
					// shift the results;
					psrlw xmm6, 8;
					psrlw xmm7, 8;
					// pack back
					packuswb xmm6, xmm7; // xmm6 <- xmm6{}xmm7 low bits;
					mov eax, dword ptr [pDst + 4];
					movdqu [eax], xmm6; // done for this component;

These lines perform the same calculations previously described for the red channel, 
but for the green channel, pDst[1]. The final green value is calculated and stored in 
pDst[1].

					// blending the blue;
					// load d0
					mov eax, dword ptr[pDst + 8]; 
					movdqu xmm1, [eax]; // xmm1 = pDst[0]
					movdqa xmm6, xmm1;
					punpcklbw xmm6, xmm0; // xmm6 <- pDst[0] low 16bit
					movdqa xmm7, xmm1;
					punpckhbw xmm7, xmm0; // xmm7 <- pDst[0] high, 16 bit
					// load the ff constant
					movdqu xmm4, [ffconst]; // xmm4 <- ff
					movdqa xmm5, xmm4; 
					psubw  xmm5, xmm2; // xmm5 = ff - a0
					pmullw xmm6, xmm5; // xmm6 = (ff - a0) * d0;
					// now for the upper bits
					movdqa xmm5, xmm4;
					psubw  xmm5, xmm3; // xmm5 = ff - a1
					pmullw xmm7, xmm5; // xmm7 = (ff - a1) * d1;
					// load the source;
					mov eax, dword ptr[pSrc + 8];
					movdqu xmm1, [eax]; // xmm1 = pSrc[0]
					// low bits of pSrc[0]
					movdqa xmm5, xmm1;
					punpcklbw xmm5, xmm0; // xmm5 = pSrc[0], low, 16 bit;
					pmullw xmm5, xmm2; // xmm5 = s0 * a0;
					paddw xmm6, xmm5; // xmm6 = s0 * a0 + (ff - a0) * d0;
					// high bits of pSrc[0]
					movdqa xmm5, xmm1;
					punpckhbw xmm5, xmm0;
					pmullw xmm5, xmm3; // xmm5 = s1 * a1
					paddw xmm7, xmm5; // xmm7 = s1 * a1 + (ff - a1) * d1;
					// shift the results;
					psrlw xmm6, 8;
					psrlw xmm7, 8;
					// pack back
					packuswb xmm6, xmm7; // xmm6 <- xmm6{}xmm7 low bits;
					mov eax, dword ptr [pDst + 8];
					movdqu [eax], xmm6; // done for this component;
				};

These lines perform the same calculations previously described for the red and green 
channels, but for the blue channel, pDst[2]. The final blue value is calculated and 
stored in pDst[2]. This also marks the end of the inline asm code used in this function.

				pSrc[0] += 16;
				pSrc[1] += 16;
				pSrc[2] += 16;
				pSrc[3] += 16;

				pDst[0] += 16;
				pDst[1] += 16;
				pDst[2] += 16;

The last few lines of code here simply increment the coordinate values for the source 
and destination images. Like with the SIMD_EMMX_INTRINSICS mode, the for loop operates on 
bits rather than pixels, which is why the increment amount is 16 rather than 1.

----- Execution Speed Comparison -----




==========================================================================================
    ## Part C
==========================================================================================


==========================================================================================
    ## Part D
==========================================================================================
    
    